---
layout: post
comments: true
categories: java基础
---
## 线程安全性
要编写线程安全的代码，其核心在于对对象状态的访问进行管理，特别是对共享的和可变的状态的访问。
一提到java同步，除了想到synchronized加锁方式，还应该想到volatile变量，显示锁以及原子变量。

### 一、线程的安全性
线程的安全性太难定义了。
什么样的类才是线程安全的类？


当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的
同步或者协同，这个类都能够表现出正确的行为，那么就称这个类是线程安全的。

在线程安全类中，封装了必要的同步机制，因此客户端无须进一步的采取同步措施。

无状态的对象一定是线程安全的。

### 二、原子性
什么是操作的原子性，个人理解原子性是指一个或者一系列操作过程中，所依赖的中间变量或者状态，都不应该被其他线程修改。在
并发编程中，由于不恰当的执行时序而出现的不正确的结果，这种情况称为**竞态条件**。

为了保证线程安全性，“先检查后执行”和“读取-修改-写入”等操作必须是原子的。这些操作被称为符合操作。  
这段代码使用了java.util.concurrent.atomic包中的原子变量。
  
```
@ThreadSafe
public class CountingFactorizer implements Servlet {
    private final AtomicLong count = new AtomicLong(0);
    
    public long getCount() {
        return count.get();
    }
    
    public void service (ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger [] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }

}
```
在实际情况中，应尽可能的使用现有的线程安全对象来管理类状态。与非线程安全对象相比，判断线程安全对象的可能状态及其状态
转换情况要更为容易。

### 三、加锁机制

