<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>灰度blog</title>
    <description>用不完的笔记本</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 16 Aug 2016 16:20:09 +0800</pubDate>
    <lastBuildDate>Tue, 16 Aug 2016 16:20:09 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Java虚拟机的内存模型</title>
        <description>&lt;h2 id=&quot;java&quot;&gt;Java内存模型&lt;/h2&gt;
&lt;p&gt;java内存模型如何划分,一般人们会粗糙的划分为堆和栈,其中堆是垃圾回收的区域,对象
在这里完成自己的生命周期。
详细一点的划分,一般把java内存划分为:方法区、堆、栈、本地方法区、PC寄存器。&lt;/p&gt;

&lt;p&gt;方法区:&lt;/p&gt;

&lt;p&gt;类加载器将java类加载后,相应的类信息会保存在方法区,包括静态变量,构造器,方法等。
方法区由多个线程共享。&lt;/p&gt;

&lt;p&gt;堆:&lt;/p&gt;

&lt;p&gt;对象的产生,活动,终结区域。堆是由多个线程共享的。&lt;/p&gt;

&lt;p&gt;pc寄存器:&lt;/p&gt;

&lt;p&gt;每个线程都有自己的pc寄存器,保存jvm当前正在执行的指令地址。&lt;/p&gt;

&lt;p&gt;栈:&lt;/p&gt;

&lt;p&gt;每个线程都有自己的栈,以栈贞的形式保存局部变量,只有压栈和出栈操作。主要保存局部变量
,中间结果等。&lt;/p&gt;

&lt;p&gt;本地方法栈:&lt;/p&gt;

&lt;p&gt;支持一些本地方法调用,与栈类似。&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/16/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
        <guid isPermaLink="true">/2016/08/16/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>操作系统的内存管理</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;操作系统的内存管理&lt;/h2&gt;

&lt;p&gt;操作系统对内存的划分和动态分配:&lt;/p&gt;

&lt;p&gt;1、内存空间的分配与回收,包括内存的管理与共享。&lt;/p&gt;

&lt;p&gt;2、地址转换,把逻辑地址转换成物理地址。&lt;/p&gt;

&lt;p&gt;3、内存空间的扩充,利用虚拟存储技术或者自动覆盖技术,从逻辑上扩充内存。&lt;/p&gt;

&lt;p&gt;4、存储保护,保证各道作业在各自的存储空间内运行,互不干扰。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;一、逻辑地址和相对地址&lt;/h3&gt;
&lt;p&gt;每个模块都是从0号单元开始编址,成为模块的相对地址。当链接程序将各个模块链接
成一个完整的可执行程序时,链接程序会顺次统一模块地址,最终构成一个从0开始编码
的逻辑地址空间。&lt;/p&gt;

&lt;p&gt;物理地址是真实地址,操作系统负责逻辑地址和物理地址的转换,将逻辑地址转换成
物理地址的过程称为地址重定位。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;二、内存分配管理方式&lt;/h3&gt;
&lt;p&gt;内存分配分为连续和非连续两种。
连续分配,是指为用户进行分配一块连续的内存空间,非连续方式允许同一用户进程
分配到非连续的空间。&lt;/p&gt;

&lt;p&gt;连续内存分配方式几乎被淘汰,先不管。(单一连续分配、固定分区分配、动态分区分配)
非连续内存分配方式分为分页和分段,分页又根据是否一次性载入所有页面分为基本分页和
请求分页。&lt;/p&gt;

&lt;p&gt;基本分页:&lt;/p&gt;

&lt;p&gt;页块的大小相对于分区要小很多,进程也需要按块划分,进程运行时按块主动申请
地址空间,这样,进程只会在为最后一个不完整的块申请空间时才会产生内部碎片。&lt;/p&gt;

&lt;p&gt;页面大小是2的整数幂。地址结构分为页号P和页内地址偏移量M。系统为每个进程建立了页表,
记录页面在内存中对应的物理块号。页表实现了页号到物理块号的映射。&lt;/p&gt;

&lt;p&gt;基本分段:&lt;/p&gt;

&lt;p&gt;段式管理方式按照用户进程中的自然段划分逻辑地址空间。例如,用户进程由主程序、
两个子程序、栈和一段数据组成,就可以把这个用户进程分为5个段,每个段从0开始编址。其逻辑地址
有段号S和段内地址偏移量组成。&lt;/p&gt;

&lt;p&gt;段页式管理方式:&lt;/p&gt;

&lt;p&gt;页式管理能够有效的提高内存的利用率,而段式管理能够反映程序的逻辑结构并
有利于段的共享。在段页式系统中,作业首先分段,每个段再分成若干大小固定的页。
作业的逻辑地址分为三个部分:段号、页号、页内偏移量。为了实现地址转换,系统为每个进程
建立一张段表,而每个段有一张页表。&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">/2016/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        
        
        <category>技术文档</category>
        
      </item>
    
      <item>
        <title>数据库的隔离级别</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;数据库的隔离级别&lt;/h2&gt;

&lt;h3 id=&quot;read-uncommited-&quot;&gt;1、Read Uncommited 读未提交&lt;/h3&gt;
&lt;p&gt;可能读到脏数据,即某个事务修改但是还未提交的数据。&lt;/p&gt;

&lt;h3 id=&quot;read-commit-&quot;&gt;2、Read Commit 读提交&lt;/h3&gt;
&lt;p&gt;读到的数据都是已经提交的数据,即当前读到的数据可能已经被其他事务修改但是还未提交,再次
读取时可能会出现数据不一致的现象。&lt;/p&gt;

&lt;h3 id=&quot;reapeatable-read-&quot;&gt;3、Reapeatable read 重复读&lt;/h3&gt;
&lt;p&gt;一旦A事务开始,事务B就不能对事务A操作的数据行进行修改,即事务A期间多次读取到
的结果保证一致。可能出现幻读。一个经典的场景是:一个事务用Where子句来检索一
个表的数据，另一个事务插入一条新的记录，并且符合Where条件，
这样，第一个事务用同一个where条件来检索数据后，就会多出一条记录。&lt;/p&gt;

&lt;h3 id=&quot;serializable-&quot;&gt;4、Serializable 序列化&lt;/h3&gt;
&lt;p&gt;所有的事务都按顺序执行&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
        <guid isPermaLink="true">/2016/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
        
        
        <category>paracraft</category>
        
      </item>
    
      <item>
        <title>日常随记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;日常随记-我和魔兽&lt;/h2&gt;

&lt;p&gt;这个周末,wca中韩对抗赛迎来了最后两个比赛日。
中国代表队的队员有:&lt;/p&gt;

&lt;p&gt;INFI、TH000、Fly100%、120、life。&lt;/p&gt;

&lt;p&gt;其中120和life都是小将,打得生猛但是明显缺乏比赛经验,而这次比赛INFI的表现也不尽如人意,
韩国代表队队员有:&lt;/p&gt;

&lt;p&gt;LawLiet、Lyn、FoCus、check、remind。&lt;/p&gt;

&lt;p&gt;周六的比赛lyn神实在是太亮眼了,KOF赛制,1个打6个,同样的兽族虐了fly两次。
周日的比赛,开始时打得有来有回,韩国人还略占优势,直到lyn神再次上场,1个打3个,终结
了中国队,也标志着这届wca中韩对抗赛以中国对的彻底失败而告终。&lt;/p&gt;

&lt;p&gt;中国队输了,而且输的并不光彩,lyn神的地位看起来简直无可撼动。难道中国魔兽的实力
真的和韩国队差距这么大吗?我个人认为并不是。面对这次代表了国家荣誉的比赛,中国
队员明显没有做好充分的准备,准备不足时这次失利的最大原因,尤其是2v2的比赛,韩国队
在战绩上几乎碾压了中国队。&lt;/p&gt;

&lt;p&gt;在说说1v1比赛,比赛开始的几天,lyn只打2v2,不打1v1,让人感觉lyn神只认真准备了2v2,没有
准备1v1,结果大家也看到了。lyn神的硬实力并不比任何一位中国选手强,但是却对中国选手
的打法非常熟悉,可是中国选手对lyn神1v1的打法非常不适应。完全没有针对lyn神做过研究。
最终输掉比赛,也是实力+状态+运气的综合结果吧。&lt;/p&gt;

&lt;p&gt;好了,虽然是代表国家,但是作为魔兽实力最强的两个国家,中国输了韩国也很正常。而且
魔兽争霸毕竟是一款已经衰落的游戏,主力玩家可能都和我年龄差不多,要么读研,要么已经工作
很久了。能继续有顶尖选选手玩这款游戏,我已经很欣慰,希望选手们继续努力。&lt;/p&gt;

&lt;p&gt;说了这么多,我其实是想记录下我和魔兽的缘分。
记得小学三年级的时候,家里买了第一台电脑,父母忙着过计算机二级,每天学些word,ppt
等乱起八糟的东西,而我自然用电脑玩游戏。&lt;/p&gt;

&lt;p&gt;魔兽这款游戏,第一次玩还是借的楼上的光盘,5块钱一张的盗版盘,在楼上电脑上装不了,在我家一下就
装好了,哈哈,非常开心,当时怎么也想不到,这款游戏到今天,已经陪了我14年。&lt;/p&gt;

&lt;p&gt;当时有电脑的人家并不很多,我们一些好朋友回来我家里玩,一起打打电脑,第一次打败中等
电脑的时候,还找小伙伴炫耀了一番。慢慢上初中,玩的小伙伴多了一点,基本上都是我带动起来
的,我们就去网吧打对战。&lt;/p&gt;

&lt;p&gt;我第一次进网吧打对战,把对方虐的超级惨。一战奠定魔兽霸主地位,当时成绩很好,在初中
也颇有名气。那时每天放学,要么打魔兽,要么就是出去打篮球,现在回想起来真的是一段
逍遥快活的日子。&lt;/p&gt;

&lt;p&gt;初三转学了,搬到了外地,以前的同学举办了第一届比赛,留下的QQ群至今还加着,那段时候我没怎么练习,
水平已经被他们渐渐拉开了,再也不是霸主了。我也曾以为我会渐渐告别魔兽。&lt;/p&gt;

&lt;p&gt;高中三年,大部分打魔兽的同学都去打dota了,我高中没怎么玩游戏,考上了不错的大学,
没有了高考的压力,确也没有了玩游戏的兴致。刚上大学的时候,和室友玩了一段时间的dota,
水平一直很差,天梯也就1000分,属于送经验的。&lt;/p&gt;

&lt;p&gt;再次回归魔兽,可能是由于偶尔在土豆网上看到了桥林的视频吧,回想起moon称霸封神的岁月,那是
每一个NE玩家的荣耀,没错的,我的种族是暗夜精灵。我试着自己打了几把,感觉水平并没有退步太多,也许是以前就太菜了。&lt;/p&gt;

&lt;p&gt;我现在还是会关注魔兽比赛,但是自己几乎不打了,实在没有精力去研究那么多的细节了,这款游戏的难度实在太大,
最顶尖的职业选手在比赛中也会失误频频,有各种操作不到位的地方。而dota职业选手往往给人感觉操作
逆天完美。&lt;/p&gt;

&lt;p&gt;以后会怎么样呢。。。谁知道&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/14/%E6%97%A5%E5%B8%B8%E9%9A%8F%E8%AE%B0/</link>
        <guid isPermaLink="true">/2016/08/14/%E6%97%A5%E5%B8%B8%E9%9A%8F%E8%AE%B0/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>深入理解java虚拟机之垃圾回收</title>
        <description>&lt;h2 id=&quot;java&quot;&gt;深入理解Java虚拟机——垃圾回收&lt;/h2&gt;

&lt;p&gt;先说点题外话,今天写这篇文章,也算是一次面试总结吧,以前我了解过垃圾回收的基本知识,像引用计数、标记清除、复制算法、标记整理等。还有堆内存划分,新生代、老年代、持久带的概念都有一定了解,不过今天面试的问题彻底把我难住了。&lt;/p&gt;

&lt;p&gt;就不提是哪家了,去面的提前批,看我的本科不是计算机专业,就问了一堆操作系统的”基础”知识,感觉答得不是很好,最后就问到了java的垃圾回收。&lt;/p&gt;

&lt;p&gt;问题是:你是用Java的,java和C++之间有堵墙,这堵墙就是内存空间的回收。Java有垃圾回收机制,那么一旦java内存溢出,应该如何查找错误呢,用过哪些分析工具吗?
还有,你是在XX实习过是吧,你们的QPS大概多少:&lt;/p&gt;

&lt;p&gt;答:大概2000左右。&lt;/p&gt;

&lt;p&gt;接着问:哦,那你应该还不会遇到这个问题,就是当QPS上万以后,可能会由于Java的垃圾回收,导致系统周期性的波动,造成系统很不稳定,为了解决这个问题,在编程的时候应该注意些什么?&lt;/p&gt;

&lt;p&gt;问到这个问题我是一脸懵逼啊,完全没想过,可能面试官也看出来了,也没有提示的意思,开始教育。&lt;/p&gt;

&lt;p&gt;接着说:这些问题都是基本问题,优秀的程序员不是要遇到了问题才去想如何解决的,你回去可以好好考虑下这些问题。(到这就知道彻底没戏了,后面寒暄几句就走了)&lt;/p&gt;

&lt;p&gt;好了,知道了自己的不足,就找到了努力的方向,看来自己的基础知识确实还不够扎实,平时思考也不够多,这次总结垃圾回收,就当做是一次复习吧。&lt;/p&gt;

&lt;h3 id=&quot;java-1&quot;&gt;什么是Java垃圾回收?&lt;/h3&gt;
</description>
        <pubDate>Sat, 13 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
        <guid isPermaLink="true">/2016/08/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>Kmp Algorithm</title>
        <description>&lt;h2 id=&quot;kmp&quot;&gt;kmp算法&lt;/h2&gt;

&lt;p&gt;这道题目用到了kmp算法，很经典。&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/13/kmp-algorithm/</link>
        <guid isPermaLink="true">/2016/08/13/kmp-algorithm/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>Java Summary</title>
        <description>&lt;h2 id=&quot;java&quot;&gt;Java基础知识总结&lt;/h2&gt;

&lt;h3 id=&quot;java-1&quot;&gt;一、java中有哪些类是线程安全的,哪些类是线程非安全的。&lt;/h3&gt;
&lt;p&gt;这个问题是java面试中,经常问到的一道题,回忆一下,好像自己刷题的时候用到的所有容器类都是线程非安全的。。。&lt;/p&gt;

&lt;p&gt;线程安全的类包括:
StringBuffer、Vector、Stack、HashTable。
说明一下,其中Vector和Hash已经常用了,需要保证线程安全的时候一般都会用java并发工具包(java.util.concurrent)下面的容器替代。
线程非安全的类,一般都会在文档中特别注明。&lt;/p&gt;

&lt;p&gt;线程非安全类包括
StringBuilder、ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet、HashMap、TreeMap、LinkedHashMap&lt;/p&gt;

&lt;p&gt;List接口的实现类:
LinkedList、ArrayList、Vector、Stack&lt;/p&gt;

&lt;p&gt;Set接口的实现类:
HashSet、TreeSet、LinkedHashSet&lt;/p&gt;

&lt;p&gt;Map接口的实现类:
HashMap、TreeMap、HashTable、LinkedHashMap&lt;/p&gt;

&lt;h3 id=&quot;treemaptreeset&quot;&gt;二、TreeMap和TreeSet的使用场景&lt;/h3&gt;
&lt;p&gt;TreeMap和TreeSet都是基于二叉搜索树(BST)的,所有要求泛型对象必须实现了comparable接口或者在构造时传入了comparator比较器。
而基于hash的HashMap和HashSet都是利用equals方法进行比较的,所有对象都有的内置方法,所有不需要特殊处理。&lt;/p&gt;

&lt;p&gt;在效率上,肯定是hash的查找效率更高,为常数时间。但是tree结构更适合排序较多的场合。&lt;/p&gt;

&lt;h3 id=&quot;linkedhashmaplinkedhashset&quot;&gt;三、关于linkedHashMap和LinkedHashSet&lt;/h3&gt;
&lt;p&gt;LinkedHashMap可以选择排列方式,默认的参数为false,表示按照插入顺序进行排列,遍历时也是按照插入的先后顺序进行遍历的。当传入的参数为true时,key的排列方式为哪个最后访问(插入或者更新),哪个就排在前面。这个时候就不能用迭代器进行遍历了。&lt;/p&gt;

&lt;p&gt;LinkedHashSet是按照插入方式进行排列的。&lt;/p&gt;

&lt;p&gt;注意:当按照插入方式进行排列时,如果set中已经存在某个value,或者map中已经存在某个key,重新插入并不会更改其排列顺序。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;四、关于值类型和引用类型&lt;/h3&gt;
&lt;p&gt;对于java的基本类型(int long double char boolean byte) ‘==’ 符号比较的是值。
对于引用类型 ‘==’ 符号比较的是引用值,即是否是同一个对象。&lt;/p&gt;

&lt;h3 id=&quot;equalshashcode&quot;&gt;五、关于对象的equals方法和hashCode方法&lt;/h3&gt;
&lt;p&gt;为了弄清这个问题,先来看一下Object规范:
1、在应用程序执行期间,只要对象的equals方法比较操作用到的信息没有被修改,那么对于同一个对象的多次调用,hashCode方法都必须始终如一的返回同一个整数。在同一个程序多次执行的过程中,每次执行返回的结果可以不同。&lt;/p&gt;

&lt;p&gt;2、如果两个对象的equals方法比较是相等的,那么调用者两个对象的hashCode方法,必须返回同样的整数。&lt;/p&gt;

&lt;p&gt;3、如果两个对象根据equals方法比较是不相等的,那么调用还是hashCode方法,可以返回相同的整数,但是不一样的整数可以提高散列表(hash表)性能。&lt;/p&gt;

&lt;h3 id=&quot;tostringtostring&quot;&gt;六、设计一个新的对象,如果有可能用到toString方法,记得始终要覆盖toString方法。&lt;/h3&gt;
&lt;p&gt;对象默认的toString方法返回值为完整类名(包名+类名)+@+32位散列值的16进制表示。&lt;/p&gt;

&lt;h3 id=&quot;integer128&quot;&gt;七、关于Integer类数值小于128比较时自动解包&lt;/h3&gt;
&lt;p&gt;这算是一个细节问题了,不知道很正常,而且实际意义不大。重点是要记住,比较Integer类时,一定先解包,能用基本类型的时候,就用基本类型,不要用对应的打包类型。&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/13/java-summary/</link>
        <guid isPermaLink="true">/2016/08/13/java-summary/</guid>
        
        
        <category>java基础</category>
        
      </item>
    
      <item>
        <title>hello jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def print_hi(name)
  puts &quot;Hi, #{name}&quot;
end
print_hi('Tom')
#=&amp;gt; prints 'Hi, Tom' to STDOUT.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Tue, 10 Feb 2015 23:14:54 +0800</pubDate>
        <link>/2015/02/10/welcome-to-jekyll/</link>
        <guid isPermaLink="true">/2015/02/10/welcome-to-jekyll/</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
