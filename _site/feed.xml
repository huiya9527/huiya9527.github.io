<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>灰度blog</title>
    <description>用不完的笔记本</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 13 Aug 2016 22:17:25 +0800</pubDate>
    <lastBuildDate>Sat, 13 Aug 2016 22:17:25 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Kmp Algorithm</title>
        <description>&lt;h2 id=&quot;kmp&quot;&gt;kmp算法&lt;/h2&gt;

&lt;p&gt;这道题目用到了kmp算法，很经典。&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/13/kmp-algorithm/</link>
        <guid isPermaLink="true">/2016/08/13/kmp-algorithm/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>Java Summary</title>
        <description>&lt;h2 id=&quot;java&quot;&gt;Java基础知识总结&lt;/h2&gt;

&lt;h3 id=&quot;java-1&quot;&gt;一、java中有哪些类是线程安全的,哪些类是线程非安全的。&lt;/h3&gt;
&lt;p&gt;这个问题是java面试中,经常问到的一道题,回忆一下,好像自己刷题的时候用到的所有容器类都是线程非安全的。。。&lt;/p&gt;

&lt;p&gt;线程安全的类包括:
StringBuffer、Vector、Stack、HashTable。
说明一下,其中Vector和Hash已经常用了,需要保证线程安全的时候一般都会用java并发工具包(java.util.concurrent)下面的容器替代。
线程非安全的类,一般都会在文档中特别注明。&lt;/p&gt;

&lt;p&gt;线程非安全类包括
StringBuilder、ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet、HashMap、TreeMap、LinkedHashMap&lt;/p&gt;

&lt;p&gt;List接口的实现类:
LinkedList、ArrayList、Vector、Stack&lt;/p&gt;

&lt;p&gt;Set接口的实现类:
HashSet、TreeSet、LinkedHashSet&lt;/p&gt;

&lt;p&gt;Map接口的实现类:
HashMap、TreeMap、HashTable、LinkedHashMap&lt;/p&gt;

&lt;h3 id=&quot;treemaptreeset&quot;&gt;二、TreeMap和TreeSet的使用场景&lt;/h3&gt;
&lt;p&gt;TreeMap和TreeSet都是基于二叉搜索树(BST)的,所有要求泛型对象必须实现了comparable接口或者在构造时传入了comparator比较器。
而基于hash的HashMap和HashSet都是利用equals方法进行比较的,所有对象都有的内置方法,所有不需要特殊处理。&lt;/p&gt;

&lt;p&gt;在效率上,肯定是hash的查找效率更高,为常数时间。但是tree结构更适合排序较多的场合。&lt;/p&gt;

&lt;h3 id=&quot;linkedhashmaplinkedhashset&quot;&gt;三、关于linkedHashMap和LinkedHashSet&lt;/h3&gt;
&lt;p&gt;LinkedHashMap可以选择排列方式,默认的参数为false,表示按照插入顺序进行排列,遍历时也是按照插入的先后顺序进行遍历的。当传入的参数为true时,key的排列方式为哪个最后访问(插入或者更新),哪个就排在前面。这个时候就不能用迭代器进行遍历了。&lt;/p&gt;

&lt;p&gt;LinkedHashSet是按照插入方式进行排列的。&lt;/p&gt;

&lt;p&gt;注意:当按照插入方式进行排列时,如果set中已经存在某个value,或者map中已经存在某个key,重新插入并不会更改其排列顺序。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;四、关于值类型和引用类型&lt;/h3&gt;
&lt;p&gt;对于java的基本类型(int long double char boolean byte) ‘==’ 符号比较的是值。
对于引用类型 ‘==’ 符号比较的是引用值,即是否是同一个对象。&lt;/p&gt;

&lt;h3 id=&quot;equalshashcode&quot;&gt;五、关于对象的equals方法和hashCode方法&lt;/h3&gt;
&lt;p&gt;为了弄清这个问题,先来看一下Object规范:
1、在应用程序执行期间,只要对象的equals方法比较操作用到的信息没有被修改,那么对于同一个对象的多次调用,hashCode方法都必须始终如一的返回同一个整数。在同一个程序多次执行的过程中,每次执行返回的结果可以不同。&lt;/p&gt;

&lt;p&gt;2、如果两个对象的equals方法比较是相等的,那么调用者两个对象的hashCode方法,必须返回同样的整数。&lt;/p&gt;

&lt;p&gt;3、如果两个对象根据equals方法比较是不相等的,那么调用还是hashCode方法,可以返回相同的整数,但是不一样的整数可以提高散列表(hash表)性能。&lt;/p&gt;

&lt;h3 id=&quot;tostringtostring&quot;&gt;六、设计一个新的对象,如果有可能用到toString方法,记得始终要覆盖toString方法。&lt;/h3&gt;
&lt;p&gt;对象默认的toString方法返回值为完整类名(包名+类名)+@+32位散列值的16进制表示。&lt;/p&gt;

&lt;h3 id=&quot;integer128&quot;&gt;七、关于Integer类数值小于128比较时自动解包&lt;/h3&gt;
&lt;p&gt;这算是一个细节问题了,不知道很正常,而且实际意义不大。重点是要记住,比较Integer类时,一定先解包,能用基本类型的时候,就用基本类型,不要用对应的打包类型。&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/13/java-summary/</link>
        <guid isPermaLink="true">/2016/08/13/java-summary/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>Empty Template</title>
        <description>&lt;h2 id=&quot;empty-diary-template&quot;&gt;Empty diary template&lt;/h2&gt;

&lt;p&gt;Empty post template&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Dec 2015 00:00:00 +0800</pubDate>
        <link>/2015/12/28/empty-template/</link>
        <guid isPermaLink="true">/2015/12/28/empty-template/</guid>
        
        
        <category>paracraft</category>
        
      </item>
    
      <item>
        <title>Empty Template</title>
        <description>&lt;h2 id=&quot;empty-npl-tutorial-template&quot;&gt;Empty npl tutorial template&lt;/h2&gt;

&lt;p&gt;Empty post template&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Dec 2015 00:00:00 +0800</pubDate>
        <link>/2015/12/28/empty-template/</link>
        <guid isPermaLink="true">/2015/12/28/empty-template/</guid>
        
        
        <category>npl</category>
        
      </item>
    
      <item>
        <title>Empty Template</title>
        <description>&lt;h2 id=&quot;empty-diary-template&quot;&gt;Empty diary template&lt;/h2&gt;

&lt;p&gt;Empty post template&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Dec 2015 00:00:00 +0800</pubDate>
        <link>/2015/12/28/empty-template/</link>
        <guid isPermaLink="true">/2015/12/28/empty-template/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>useful links</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#paracraft&quot; id=&quot;markdown-toc-paracraft&quot;&gt;ParaCraft&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#npl&quot; id=&quot;markdown-toc-npl&quot;&gt;NPL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;paracraft&quot;&gt;ParaCraft&lt;/h3&gt;
&lt;p&gt;http://www.paracraft.cn&lt;/p&gt;

&lt;h3 id=&quot;npl&quot;&gt;NPL&lt;/h3&gt;
&lt;p&gt;http://www.nplproject.com&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Dec 2015 00:00:00 +0800</pubDate>
        <link>/2015/12/27/useful-links/</link>
        <guid isPermaLink="true">/2015/12/27/useful-links/</guid>
        
        
      </item>
    
      <item>
        <title>hello jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def print_hi(name)
  puts &quot;Hi, #{name}&quot;
end
print_hi('Tom')
#=&amp;gt; prints 'Hi, Tom' to STDOUT.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Tue, 10 Feb 2015 23:14:54 +0800</pubDate>
        <link>/2015/02/10/welcome-to-jekyll/</link>
        <guid isPermaLink="true">/2015/02/10/welcome-to-jekyll/</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
